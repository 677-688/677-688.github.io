---
date: 2025-12-28 18:30:23
title: 计算机系统基础知识
permalink: /pages/79c03e
categories:
  - 第1章 计算机系统知识
tags:
  - 第1章 计算机系统知识
coverImg: /backgrounds/03.jpeg
---

# 计算机系统基础知识 ⭐

## 1. 计算机系统硬件基本组成

1. 计算机系统是由硬件和软件组成 
2. 硬件分为：运算器、控制器、存储器、输入设备、输出设备
3. 中央处理单元：运算器、控制器等部件集成在CPU中，也是硬件系统的核心，用于数据的加工处理，完成各种算数、逻辑运算、控制功能
4. 存储器：计算机系统的记忆设备，分为
	1. 内部存储：速度高、容量小，一般临时存放程序、数据及中间结果。
	2. 外部存储：速度慢、容量大，可以长期保存程序和数据。
5. 输入设备和输出设备合称为外部设备（外设）
	1. 输入设备用于输入原始数据及各种命令
	2. 输出设备用于输出计算机运行的结果

## 2. 中央处理单元（CPU）

> 计算及系统的核心部件，它负责获取程序指令、对指令进行译码并加以执行

### 2.1 CPU的功能：

1. 程序控制：CPU通过执行指令控制程序的执行顺序
2. 操作控制：CPU产生每条指令的操作信号并送到对应的部件，控制相应的部件按指令的功能要求操作
3. 时间控制：CPU对各种操作进行时间上的控制，就是指令执行过程中操作信号的出现时间、持续时间及出现的时间顺序都需要严格控制
4. 数据处理：CPU通过对数据进行算数运算及逻辑运算等方式进行加工处理，数据加工的结果返给程序，这就是CPU最根本的任务
5. 其他：还需要对系统内部和外部的中断（异常）做响应，进行响应的处理

### 2.2 CPU的组成：

> CPU 主要有运算器、控制器、寄存器和内部总线等部件组成 

<img src="/content-assets/CPU的组成.jpg" width="500" alt="CPU的组成">
	
#### 2.2.1 运算器

1. 执行所有计算和逻辑运算
2. 组成部件及功能：
	1. 算数逻辑单位（ALU）：最重要的组成部件，负责处理数据， 实现对数据的算数、逻辑运算
	2. 累加寄存器（AC）：累加器，是一个通用的寄存器，功能是当运算器的算术逻辑单元执行算数或逻辑运算时，为ALU提供一个工作区。
	3. 数据缓冲寄存器（DR）：作为CPU和内存、外部设备之间数据传送的中转站，操作速度上的缓冲。在对内内存储器读写操作时，用DR在那时存放内存储器读写的一条指令或一个数据字，将不用时间段内读写的数据隔离开来
	4. 状态条件寄存器（PSW）：保存有算数指令和逻辑指令运行或测试的结果建立的各种条件码内容

#### 2.2.2 控制器

1. 指挥协调CPU所有操作，用于控制整个CPU的工作，决定计算机运行过程的自动化。保证程序的正确执行，以及处理异常事件
2. 组成部分：
	1. **指令控制逻辑**：完成取指令、分析指令、执行指令的操作，过程分为取指令、指令译码、按指令操作码执行、形成下一条指令地址等步骤
		1. **指令寄存器**（IR）：CPU执行一条指令时，先从内存储器渠道缓冲寄存器中，再送入IR暂存，指令译码器根据IR的内容产生各种微操作指令，控制其他的组成部件工作，完成所需的功能
		2. **程序计数器**（PC）：寄存信息和计数两种功能，又称指令计数器
			1. 程序执行情况分：顺序执行、转移执行。 程序开始执行前，将程序的其实地址送入PC，该地址再程序加载到内存时确定，所以PC的内容时程序第一条指令的地址
			2. 由于大部分指令都是按顺序执行的，所以修改的过程都是简单地对PC中的指令地址+1，
			3. 当遇到转移指令时，后续指令的地址根据当前指令的地址加上一个向前或向后的位移量得到，或者根据转移指令给出直接转移的地址得到。
		3. **地址寄存器**（AR）：AR保存当前CPU所访问的内存单元的地址。由于内存和CPU存在操作速度的差异，所需要使用AR保持地址信息，知道内存的读写操作完成为止。
		4. **指令译码器**（ID）：
			1. 指令包含操作码和地址码，为了能执行任何给定的指令，必须对操作码进行分析，保证能识别所完成的操作。
			2. 就是对指令中的操作码字段进行分析解释，识别该指令规定的操作，向操作控制器发出具体的控制信号，控制各部件工作，完成所需功能
	2. **时序控制逻辑**：为每条指令按时间顺序提供应有的控制信号。
	3. **总线控制逻辑**：为多个功能部件服务的信息通路的控制电路。
	4. **中断控制逻辑**：用于控制各种中断请求，并根据优先级的高低对中断请求进行排队，逐个交给CPU处理。
		
#### 2.2.3 寄存器组（Registers）

|寄存器类型|功能|
|---|---|
|**程序计数器（PC）**|存放下一条指令地址|
|**指令寄存器（IR）**|存放当前执行的指令|
|**累加器（ACC）**|存储ALU运算结果|
|**标志寄存器（Flag）**|存储运算状态（溢出、零、负等）|
|**通用寄存器**|临时数据存储|
|**地址寄存器（MAR）**|存储要访问的内存地址|
|**数据寄存器（MDR）**|存储从内存读/写的数据|
|**栈指针（SP）**|指向栈顶位置|

#### 2.2.4 内部总线（Internal Buses

- **数据总线**：传输数据
- **地址总线**：传输内存地址
- **控制总线**：传输控制信号

#### 2.2.5 缓存（Cache Memory）

- **L1缓存**：最快，最小，分指令缓存和数据缓存
- **L2缓存**：较大，较慢
- **L3缓存**：最大，最慢，多核共享

#### 2.2.6 多核CPU

1. 多核就是在一个单芯片上面继承两个甚至多个处理器内核，每个内核都有自己的逻辑单位、控制单元，中断处理器、运算单位、一级 Cache、二级 Cache 共享或者独有，完整性和单核处理器内核相比完全一致。
2. 多核CPU的优点：可满足用户同时进行多任务处理的要求。
3. 单核 CPU 是交替的转换执行多个任务。 

## 3.数据表示 ⭐
 
### 3.1 基础数据表示

**位（Bit）**

- 计算机中最小的存储单位
- 只能表示 0 或 1
	
 **字节（Byte）**
 
- 8 位组成 1 字节
- 基本寻址单位
- 可表示范围：0 ~ 255（无符号）

### 3.2 无符号整数表示法
	
	8位：   0 ~ 255
	16位：  0 ~ 65,535
	32位：  0 ~ 4,294,967,295
	64位：  0 ~ 18,446,744,073,709,551,615
	
### 3.3 有符号整数表示法

#### 3.3.1 原码（Sign-Magnitude）

- 最高位表示符号（0正1负）
- 其余位表示绝对值
	
		+5 = 0000 0101
		-5 = 1000 0101

**问题**：
- 0 有两种表示：+0(0000 0000) 和 -0(1000 0000)
- 加减运算复杂
    
#### 3.3.2 反码（Ones' Complement）

- 正数：与原码相同
- 负数：符号位不变，其他位取反

		+5 = 0000 0101
		-5 = 1111 1010

#### 3.3.3 补码（Two's Complement） ⭐ **现代CPU标准**

- 正数：与原码相同
- 负数：反码 + 1

		+5 = 0000 0101
		-5 = 1111 1011  （反码1111 1010 + 1）

**补码优势**：

- 0 只有一种表示：0000 0000
- 减法可转换为加法
- 符号位可直接参与运算
- 表示范围对称

		8位补码范围：-128 ~ +127

#### 3.3.4 移码（Excess-K / Bias）

	- 主要用于浮点数的指数部分
	- 实际值 = 存储值 - 偏移量（通常为 2ⁿ⁻¹）

	偏移量 127（8位）：
	实际值 0 → 存储 127（0111 1111）
	实际值 1 → 存储 128（1000 0000）

### 3.4 浮点数表示
 
**IEEE 754 标准** ⭐ 现代标准
 
#### 3.4.1 单精度（32位）：

	S EEEEEEEE FFFFFFFFFFFFFFFFFFFFFFF
	↑ ↑        ↑
	| |        |
	符号 指数(8位)  尾数/有效数(23位)

- **符号位 S**：1位（0正1负）
- **指数 E**：8位，移码表示（偏移量 127）
- **尾数 M**：23位，隐藏1（实际24位）

**计算公式**：

	(-1)^S × 1.M × 2^(E-127)

#### 3.4.2 双精度（64位）：

- 符号位：1位
- 指数：11位（偏移量 1023）
- 尾数：52位（隐藏1，实际53位）

#### 3.4.3 特殊值表示

	单精度示例：
	零：        0 00000000 00000000000000000000000
	负零：      1 00000000 00000000000000000000000
	无穷大：    0 11111111 00000000000000000000000
	负无穷大：  1 11111111 00000000000000000000000
	NaN：      0 11111111 非零尾数

#### 3.4.4 规格化与非规格化

- **规格化数**：1 ≤ E ≤ 254（单精度）

	实际值 = (-1)^S × 1.M × 2^(E-127)

- **非规格化数**：E = 0

	实际值 = (-1)^S × 0.M × 2^(-126)  // 表示接近0的数


## 4. 校验码

### 4.1 基本概念

#### 4.1.1 为什么要校验码？
> 数据传输/存储 → 可能出错 → 需要检测/纠正 → 校验码

#### 4.1.2 常见错误类型

- **单比特错误**：1位翻转（最常见）
- **突发错误**：连续多位错误
- **删除错误**：数据位丢失
- **插入错误**：多余位插入

#### 4.1.3 校验码类型

- 奇偶校验（Parity Check） ：通过增加1个校验位，让整个数据中"1"的个数保持为奇数或偶数。
	- 就像数数，看看队伍里有多少个人
	- 如果是**偶校验**，就规定队伍总人数必须是**偶数**
	- 如果是**奇校验**，就规定队伍总人数必须是**奇数**
	- 多出来的那个人就是**校验位**
- 海明码（Hamming Code）⭐ 重要 ：不仅能发现错误，还能知道哪个位置错了并纠正它。
	- 就像给数据的位置**编号**（1,2,3,4...）
	- 安排几个"监督员"（校验位）
	- 每个监督员负责检查特定位置的数据
	- 如果出错了，监督员们"举手报告"，我们就能知道是哪个位置错了
	- 校验位放在**1、2、4、8...**（2的幂次）位置
	- 每个校验位覆盖特定的数据位组合
	- 接收方检查时，如果有错误，出错的监督员编号加起来就是错误位置
- 循环冗余校验（CRC）：用"除法求余数"的方式生成校验码，特别擅长发现连续的突发错误。
	- 把数据看成一个很大的数
	- 用另一个固定的数（生成多项式）去除它
	- 得到的**余数**就是CRC校验码
	- 发送时把数据和余数一起发出去
	- 接收方重新算余数，看看和收到的余数是否一致
- **选择哪个**：
	- 要简单快速：用奇偶校验
	- 需要纠正错误：用海明码
	- 要可靠检错：用CRC
	- 现代系统常常**组合使用**，比如先用CRC发现错误，再用海明码纠正